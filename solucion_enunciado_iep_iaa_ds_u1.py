# -*- coding: utf-8 -*-
"""Solucion_enunciado_IEP-IAA-DS_u1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MiyFfZ9nSxNxUXrgmsXsRoBumQfEwr6h

**Ejercicio 1: Movie Ratings**

En este ejercicio vamos a trabajar con un conjunto de datos que contiene información sobre películas y valoraciones de usuarios.

**El fichero movies.csv contiene las siguientes columnas:**

1. **movieId:** identificador de la película.

2. **title:** título de la película.

3. **genres:** géneros de la película. Están separados por el carácter "|".
El fichero ratings.csv contiene las siguientes columnas:

4. **userId:** identificador del usuario que ha valorado la película.

5. **movieId:** identificador de la película.

6. **rating:** valoración de la película por el usuario, en una escala de 0.5 a 5.

7. **timestamp:** fecha y hora en la que se realizó la valoración. Está en formato UNIX, es decir, el número de segundos que han pasado desde el 1 de enero de 1970. Luego veremos cómo convertirlo a un formato más legible.

**Carga de datos**

Lee los ficheros de datos y almacénalos en dos DataFrames de Pandas. Llámalos movies y ratings. **¿Cuántas películas y valoraciones hay en cada DataFrame?**

**Unión de DataFrames**

Añade el título y los géneros de las películas a la tabla de valoraciones de tal forma que tengamos una única tabla con toda la información. Llámala movie_ratings.


Las películas que no tengan valoraciones o ratings de películas que no conocemos no nos interesan.

*¿Cuantas valoraciones ha recibido la película "Dark Knight, The (2008)"? ¿Y de 5 estrellas?*

Calcula la valoracion media y el número de valoraciones de cada película.
Almacena el resultado en un nuevo DataFrame llamado movie_stats. La funcion size nos da el número de valoraciones, y mean la valoración media.

*¿Qué película tiene la valoración media más alta?*

Para tener un resultado más fiable filtra aquellas películas que tengan al menos 100 valoraciones y extrae el top 10 de películas con la valoración media más alta.

**Extracción del año de la película**

El año de la película se encuentra entre paréntesis en el título, añade una columna al DataFrame movies con el año de la película asumiendo que siempre se encuentra en la misma posición.

Utiliza una función lambda para extraer el año del título. Una vez que lo hayas extraído, elimina el año del título.

**Filtro por género**

*¿Cómo podríamos filtrar las películas de un género concreto?* Por ejemplo, *¿cómo podríamos obtener las películas de acción de 1993?* Piensa que la columna genres es una cadena de texto y por tanto podemos utilizar el método str.contains para filtrar por género.

**Tratamiento columna de fecha UNIX**

El campo timestamp de la tabla `ratings` está en formato UNIX, esto quiere decir que se trata de un número entero que representa los segundos que han pasado desde el 1 de enero de 1970. Para convertirlo a un formato más legible podemos utilizar la función to_datetime de Pandas. Crea una nueva columna en la tabla ratings llamada date que contenga la fecha en un formato legible. *¿Cuando fue la primera y la última valoración?*

# **Código y output**
"""

# Importar bibliotecas necesarias
import pandas as pd

# Cargar los datos desde los archivos CSV
movies = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/datos_IEP-IAA-DS_u1/movies.csv')
ratings = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/datos_IEP-IAA-DS_u1/ratings.csv')

# Verificar la cantidad de películas y valoraciones
print(f"Cantidad de películas: {movies.shape[0]}")
print(f"Cantidad de valoraciones: {ratings.shape[0]}")

# Unión de DataFrames
movie_ratings = pd.merge(ratings, movies, on='movieId')
print(f"Dimensiones del DataFrame combinado: {movie_ratings.shape}")

# Calcular valoraciones para "Dark Knight, The (2008)"
dark_knight = movie_ratings[movie_ratings['title'] == "Dark Knight, The (2008)"]
print(f"Total de valoraciones para 'Dark Knight, The (2008)': {dark_knight.shape[0]}")
print(f"Valoraciones de 5 estrellas: {dark_knight[dark_knight['rating'] == 5].shape[0]}")

# Calcular la valoración media y número de valoraciones
movie_stats = movie_ratings.groupby('title')['rating'].agg(['mean', 'size']).reset_index()
movie_stats.columns = ['title', 'mean_rating', 'num_ratings']

# Filtrar películas con al menos 100 valoraciones y encontrar el top 10
filtered_stats = movie_stats[movie_stats['num_ratings'] >= 100]
top_10_movies = filtered_stats.sort_values('mean_rating', ascending=False).head(10)
print("Top 10 películas con mayor valoración media:")
print(top_10_movies)

# Extracción del año de las películas
movies['year'] = movies['title'].str.extract(r'\((\d{4})\)', expand=False)
movies['title'] = movies['title'].str.replace(r'\(\d{4}\)', '', regex=True).str.strip()

# Filtrar películas de acción de 1993
action_movies_1993 = movies[(movies['genres'].str.contains('Action')) & (movies['year'] == '1993')]
print("Películas de acción de 1993:")
print(action_movies_1993)

# Conversión de timestamp a formato legible
ratings['date'] = pd.to_datetime(ratings['timestamp'], unit='s')
print(f"Primera valoración: {ratings['date'].min()}")
print(f"Última valoración: {ratings['date'].max()}")

import matplotlib.pyplot as plt

# Movie Ratings: Top 10 películas con mayor valoración media
top_movies = {
    "titles": [
        "Shawshank Redemption",
        "Treasure of Sierra Madre",
        "Double Indemnity",
        "Godfather",
        "Usual Suspects",
        "Seven Samurai",
        "Rear Window",
        "One Flew Over Cuckoo's Nest",
        "Third Man",
        "Big Sleep",
    ],
    "mean_ratings": [4.42, 4.37, 4.37, 4.36, 4.31, 4.28, 4.28, 4.27, 4.27, 4.27],
    "num_ratings": [1837, 113, 109, 1161, 1196, 259, 405, 793, 131, 110],
}

# Bar chart for mean ratings
plt.figure(figsize=(10, 6))
plt.barh(top_movies["titles"], top_movies["mean_ratings"], color="skyblue")
plt.xlabel("Valoración Media")
plt.ylabel("Películas")
plt.title("Top 10 Películas con Mayor Valoración Media")
plt.gca().invert_yaxis()
plt.tight_layout()
plt.show()

# Students: Nota media final por edad y sexo
final_grade_stats = {
    "age_sex": ["15 años (M)", "16 años (M)", "17 años (F)", "16 años (F)", "17 años (M)", "15 años (F)"],
    "final_grades": [12.57, 11.66, 10.82, 10.49, 10.16, 9.80],
}

# Bar chart for average grades by age and sex
plt.figure(figsize=(8, 5))
plt.bar(final_grade_stats["age_sex"], final_grade_stats["final_grades"], color="lightgreen")
plt.xlabel("Edad y Sexo")
plt.ylabel("Nota Media Final")
plt.title("Nota Media Final por Edad y Sexo")
plt.tight_layout()
plt.show()

"""# Analisis de resultados

Resultados de Movie Ratings
Cantidad de películas y valoraciones:

Películas: 45,447
Valoraciones: 500,000

Valoraciones de "Dark Knight, The (2008)":
1. Total de valoraciones: 794
2. Valoraciones de 5 estrellas: 240

Película con mayor valoración media y top 10:

1. Película con mayor valoración media: "Shawshank Redemption, The (1994)" con una media de 4.42 basada en 1,837 valoraciones.

2. Top 10 películas con mayor valoración media:

  2.1. "Shawshank Redemption, The (1994)" (Media: 4.42, Valoraciones: 1,837)

  2.2. "Treasure of the Sierra Madre, The (1948)" (Media: 4.37, Valoraciones: 113)

  2.3. "Double Indemnity (1944)" (Media: 4.36, Valoraciones: 109)

  2.4. "Godfather, The (1972)" (Media: 4.36, Valoraciones: 1,161)

  2.5. "Usual Suspects, The (1995)" (Media: 4.31, Valoraciones: 1,196)

  2.6. "Seven Samurai (Shichinin no samurai) (1954)" (Media: 4.28, Valoraciones: 259)

  2.7. "Rear Window (1954)" (Media: 4.28, Valoraciones: 405)

  2.8. "One Flew Over the Cuckoo's Nest (1975)" (Media: 4.27, Valoraciones: 793)

  2.9. "Third Man, The (1949)" (Media: 4.27, Valoraciones: 131)

  2.10. "Big Sleep, The (1946)" (Media: 4.27, Valoraciones: 110)

Películas de acción de 1993:

1. Total de películas encontradas: 102.

2. Ejemplo de películas:

  2.1 "New York Cop (Nyû Yôku no koppu)"
  2.2. "Cliffhanger"
  2.3. "Demolition Man"
  2.4. "Hard Target"
  2.5. "Heaven & Earth"

Primera y última valoración:

1. Primera valoración: 1996-03-27 17:20:36

2. Última valoración: 2017-08-04 04:52:46

**Ejercicio 2: Estudiantes**

En este ejercicio vamos a trabajar con un conjunto de datos que contiene información sobre estudiantes y sus notas. El fichero students-mat.csv ha sido extraído del repositorio de Machine Learning de la UCI.

Para consultar la descripción completa del conjunto de datos, puedes visitar el siguiente enlace:


https://archive.ics.uci.edu/ml/datasets/Student+Performance

**Carga de Datos**

Lee el fichero CSV llamado students-mat.csv y almacénalo en un DataFrame de Pandas llamado students.

¡OJO! El separador de campos es el punto y coma y no el comúnmente utilizado, la coma, que es el que se utiliza por defecto en la función read_csv. *¿Cómo puedes modificar el separador?*

Una vez cargado el fichero, muestra el número de filas y columnas del DataFrame.

**Filtro estudiantes mayores de edad**

En nuestro estudio vamos a considerar solo a los estudiantes menores de 18 años, sobrescribe el DataFrame students para que contendrá solo a los estudiantes menores de edad.

**Renombrar columnas**

Las columnas G1, G2 y G3 contienen las notas de los estudiantes en tres cursos. Renombra estas columnas a grade1, grade2 y grade3 respectivamente. Para ello, puedes utilizar el método rename de Pandas.

**Filtrado de columnas**

Vamos a reducir el tamaño del dataframe a solo las columnas que nos interesan.

Mantén las siguientes columnas: school, sex, age, activities y las renombradas grade1, grade2, grade3. Sobrescribe el DataFrame students con el resultado.

**Cálculo de aprobados por curso**

Primero crea tres columnas de tipo booleano (grade1_passed, grade2_passed, grade3_passed) que indiquen si el estudiante ha aprobado cada uno de los cursos. Un estudiante aprueba si su nota es mayor o igual a 10.

Ahora puedes contar el número de estudiantes que han aprobado cada curso.

*¿Cuántos estudiantes han aprobado los tres cursos? ¿Y cuántos no han aprobado ninguno?*

**Nota media por estudiante**

Calcula la nota media de cada estudiante y añade una nueva columna al DataFrame llamada final_grade.

**Nota media final por edad y sexo**

Calcula la nota media final de los estudiantes por edad y sexo, redondea el resultado a dos decimales. Almacena el resultado en un DataFrame llamado final_grade_stats y ordena el resultado por nota media de mayor a menor.

**Valores duplicados**

*¿Hay alguna fila duplicada en el DataFrame students? ¿Crees que tiene sentido que haya filas duplicadas en este DataFrame? ¿Las eliminarías?*

El método drop_duplicates de Pandas nos permite eliminar filas duplicadas pero *¿cómo sabemos si hay filas duplicadas?* Puedes utilizar el método duplicated para comprobar si hay filas duplicadas en un DataFrame.

# **Código y output**
"""

# Cargar los datos del archivo CSV
students = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/datos_IEP-IAA-DS_u1/student-mat.csv', sep=';')

# Mostrar el número de filas y columnas
print(f"Dimensiones del DataFrame: {students.shape}")

# Filtrar estudiantes menores de edad
students = students[students['age'] < 18]

# Renombrar columnas
students.rename(columns={'G1': 'grade1', 'G2': 'grade2', 'G3': 'grade3'}, inplace=True)

# Reducir las columnas a las necesarias
students = students[['school', 'sex', 'age', 'activities', 'grade1', 'grade2', 'grade3']]

# Crear columnas para aprobados
students['grade1_passed'] = students['grade1'] >= 10
students['grade2_passed'] = students['grade2'] >= 10
students['grade3_passed'] = students['grade3'] >= 10

# Calcular el número de aprobados
num_passed_all = students[(students['grade1_passed']) &
                          (students['grade2_passed']) &
                          (students['grade3_passed'])].shape[0]
num_failed_all = students[~(students['grade1_passed']) &
                           ~(students['grade2_passed']) &
                           ~(students['grade3_passed'])].shape[0]
print(f"Estudiantes que aprobaron los tres cursos: {num_passed_all}")
print(f"Estudiantes que no aprobaron ninguno: {num_failed_all}")

# Calcular la nota media de cada estudiante
students['final_grade'] = students[['grade1', 'grade2', 'grade3']].mean(axis=1)

# Nota media final por edad y sexo
final_grade_stats = students.groupby(['age', 'sex'])['final_grade'].mean().round(2).reset_index()
final_grade_stats.sort_values('final_grade', ascending=False, inplace=True)
print("Nota media final por edad y sexo:")
print(final_grade_stats)

# Buscar filas duplicadas
duplicates = students.duplicated().sum()
print(f"Número de filas duplicadas: {duplicates}")
if duplicates > 0:
    students = students.drop_duplicates()
    print("Filas duplicadas eliminadas.")

"""# Analisis de resultados

Dimensiones del DataFrame:

1. Filas: 395
2. Columnas: 33

Estudiantes que aprobaron:

1. Tres cursos: 167 estudiantes.
2. Ningún curso: 61 estudiantes.

Nota media final por edad y sexo:

1. Edad y sexo con mayor promedio:
  1. 15 años (M): Promedio de 12.57.
  2. 16 años (M): Promedio de 11.66.

2. Otros promedios:

  1. 17 años (F): Promedio de 10.82.
  2. 16 años (F): Promedio de 10.49.
  3. 17 años (M): Promedio de 10.16.
  4. 15 años (F): Promedio de 9.80.

3. Filas duplicadas:

  1. Número de duplicados: 15.
  2. Acción realizada: Filas duplicadas eliminadas.

# Análisis del último Punto: Duplicados en el Conjunto de Datos

En el caso de los datos de estudiantes, al buscar filas duplicadas en el DataFrame, encontramos que hay 15 filas duplicadas. Sin embargo, no deberíamos eliminarlas debido a las siguientes razones:

**Falta de un Identificador Único:**

En este conjunto de datos no existe un identificador o llave primaria única para cada estudiante, como un número de matrícula o un identificador único.

Esto hace imposible distinguir si las filas duplicadas corresponden a errores en la recopilación de datos o si se trata de estudiantes diferentes que comparten exactamente los mismos datos.

**Posibilidad de Coincidencias:**

Es posible que existan estudiantes diferentes que, por coincidencia, tengan las mismas características (edad, sexo, notas, etc.). Por lo tanto, eliminar las filas duplicadas podría resultar en la pérdida de información válida.

**Impacto en el Análisis:**

Si elimináramos estas filas sin justificación clara, estaríamos introduciendo un sesgo en los resultados al asumir que las filas duplicadas son errores, lo cual no está garantizado en este caso.

Por lo tanto, la mejor práctica en este escenario es conservar las filas duplicadas, ya que no se puede determinar con certeza si representan errores o información válida. Esto asegura que el análisis no esté influenciado por suposiciones no comprobadas.
"""